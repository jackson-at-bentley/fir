<!DOCTYPE html><html class="default" lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>fir-for-connectors</title><meta name="description" content="Documentation for fir-for-connectors"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script async src="assets/search.js" id="search-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os"</script><header class="tsd-page-toolbar">
<div class="tsd-toolbar-contents container">
<div class="table-cell" id="tsd-search" data-base=".">
<div class="field"><label for="tsd-search-field" class="tsd-widget search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M15.7824 13.833L12.6666 10.7177C12.5259 10.5771 12.3353 10.499 12.1353 10.499H11.6259C12.4884 9.39596 13.001 8.00859 13.001 6.49937C13.001 2.90909 10.0914 0 6.50048 0C2.90959 0 0 2.90909 0 6.49937C0 10.0896 2.90959 12.9987 6.50048 12.9987C8.00996 12.9987 9.39756 12.4863 10.5008 11.6239V12.1332C10.5008 12.3332 10.5789 12.5238 10.7195 12.6644L13.8354 15.7797C14.1292 16.0734 14.6042 16.0734 14.8948 15.7797L15.7793 14.8954C16.0731 14.6017 16.0731 14.1267 15.7824 13.833ZM6.50048 10.499C4.29094 10.499 2.50018 8.71165 2.50018 6.49937C2.50018 4.29021 4.28781 2.49976 6.50048 2.49976C8.71001 2.49976 10.5008 4.28708 10.5008 6.49937C10.5008 8.70852 8.71314 10.499 6.50048 10.499Z" fill="var(--color-text)"></path></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div>
<ul class="results">
<li class="state loading">Preparing search index...</li>
<li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">fir-for-connectors</a></div>
<div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><rect x="1" y="3" width="14" height="2" fill="var(--color-text)"></rect><rect x="1" y="7" width="14" height="2" fill="var(--color-text)"></rect><rect x="1" y="11" width="14" height="2" fill="var(--color-text)"></rect></svg></a></div></div></header>
<div class="container container-main">
<div class="col-8 col-content">
<div class="tsd-page-title">
<h2>fir-for-connectors</h2></div>
<div class="tsd-panel tsd-typography">
<a href="#üå≤-fir" id="üå≤-fir" style="color: inherit; text-decoration: none;">
  <h1>üå≤ fir</h1>
</a>
<p><a href="https://coveralls.io/github/jackson-at-bentley/fir"><img src="https://img.shields.io/coveralls/github/jackson-at-bentley/fir?color=green&logo=coveralls&style=flat-square" alt="Coveralls coverage badge"></a> <a href="https://www.npmjs.com/package/fir-for-connectors"><img src="https://img.shields.io/npm/v/fir-for-connectors?color=yellowgreen&logo=npm&style=flat-square" alt="NPM version badge"></a></p>

<a href="#what" id="what" style="color: inherit; text-decoration: none;">
  <h2>What?</h2>
</a>
<p>An experimental, declarative synchronizer for iTwin connectors that aims to modify the existing types in the iTwin library as little as possible. For use as a drop-in replacement of the synchronizer in iTwin&#39;s connector framework.</p>

<a href="#navigation" id="navigation" style="color: inherit; text-decoration: none;">
  <h3>Navigation</h3>
</a>
<ul>
<li><a href="#motivation-">Motivation üîç</a></li>
<li><a href="#getting-started-">Getting started üå±</a></li>
<li><a href="#extending-fir-">Extending <code>fir</code> ‚ö°</a></li>
<li><a href="https://jackson-at-bentley.github.io/fir">Docs üìÑ</a></li>
</ul>

<a href="#what-does-it-look-like" id="what-does-it-look-like" style="color: inherit; text-decoration: none;">
  <h3>What does it look like?</h3>
</a>
<p>Like the element properties you already know from iTwin.</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">linkPartition</span><span class="hl-1">: </span><span class="hl-3">Element</span><span class="hl-1">&lt;</span><span class="hl-3">InformationPartitionElementProps</span><span class="hl-1">&gt; = {</span><br/><span class="hl-1">    </span><span class="hl-4">classFullName:</span><span class="hl-1"> </span><span class="hl-4">LinkPartition</span><span class="hl-1">.</span><span class="hl-4">classFullName</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">code:</span><span class="hl-1"> </span><span class="hl-4">Code</span><span class="hl-1">.</span><span class="hl-5">createEmpty</span><span class="hl-1">(),</span><br/><span class="hl-1">    </span><span class="hl-4">model:</span><span class="hl-1"> </span><span class="hl-6">&#39;repository&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">parent:</span><span class="hl-1"> </span><span class="hl-6">&#39;root subject&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">meta:</span><span class="hl-1"> </span><span class="hl-4">partitionMeta</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">description:</span><span class="hl-1"> </span><span class="hl-6">&#39;models my links&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">to:</span><span class="hl-1"> </span><span class="hl-4">toElement</span><span class="hl-1">,</span><br/><span class="hl-1">};</span>
</code></pre>

<a href="#motivation-üîç" id="motivation-üîç" style="color: inherit; text-decoration: none;">
  <h2>Motivation üîç</h2>
</a>
<blockquote>
<p>The iTwin connectors team already maintains two connector libraries.</p>
<ol>
<li><a href="https://github.com/iTwin/connector-framework"><code>@itwin/connector-framework</code></a></li>
<li><a href="https://github.com/iTwin/pcf"><code>@itwin/pcf</code></a></li>
</ol>
<p>Why do we need a third?</p>
</blockquote>
<p>I&#39;ve been <a href="https://github.com/iTwin/connector-framework/pull/55">rather vocal</a> about the usability of the API of the synchronizer that ships with <code>@itwin/connector-framework</code>. This is an internship project and I have no expectation that it be maintained. I had an idea for how I wanted a synchronizer to work and I also wanted to use it, and that required writing it.</p>
<p><code>fir</code> is <em>only</em> a synchronizer. Its synchronization module is just under 1,000 lines of code including whole paragraphs of JSDoc and ample whitespace. <code>fir</code> makes no attempt to be a complete solution to connectors like <code>pcf</code>, and it doesn&#39;t help you run your connector like <code>connector-framework</code>. It&#39;s designed to be dropped into the connector framework, and doesn&#39;t replace it.</p>

<a href="#benefits" id="benefits" style="color: inherit; text-decoration: none;">
  <h3>Benefits</h3>
</a>
<ul>
<li><strong>Type safety.</strong> The iTwin API represents elements as bags of properties that are just plain object types in TypeScript. When inserting elements into an iModel, all of these types are narrowed to <code>ElementProps</code>. These objects already have relationships to each other through <em>ECInstanceIds</em>, which are simply the IDs of rows in an iModel&#39;s underlying SQLite database. It seems natural then to use these objects as an intermediate representation of an iModel and hang strings between them to relate them instead of IDs. This is exactly what <code>fir</code> does. By expanding iTwin&#39;s existing types, you&#39;ll never mistake the type of a property. Your connector won&#39;t compile. This is in contrast to <code>pcf</code>&#39;s approach, which trusts that the author of <code>modifyProps</code> won&#39;t make a mistake when escaping TypeScript&#39;s checks with <code>any</code>.</li>
<li><strong>Automatic dependencies.</strong> <code>fir</code> manages dependencies for you. If you forget to give an element <code>A</code> to the <code>sync</code> method, that&#39;s okay! If an element <code>B</code> is synced, all of its dependencies will be inserted into the iModel. If <code>B</code> is a child of <code>A</code>, for example, <code>A</code> and all of its dependencies will be inserted. These are the strings I mentioned above, but more formally they&#39;re relationships, called <em>navigation properties</em> in BIS. Scope relationships, repository relationships, parent relationships, model relationships.</li>
<li><strong>Models.</strong> Unlike <code>pcf</code> and <code>connector-framework</code>&#39;s synchronizer, <code>fir</code> places <em>no restrictions</em> on models. Models can contain models arbitrarily deep. The current synchronizer does not operate on models and relies on the connector author to manage them. In <code>pcf</code> you can only have models that model partition elements that are children of the root subject.</li>
<li><strong>Extendibility.</strong> If an object type has a relationship property that I forgot to handle, <code>fir</code> will give control to the connector author to map the element to its &quot;props&quot; type in iTwin.</li>
</ul>

<a href="#caveats" id="caveats" style="color: inherit; text-decoration: none;">
  <h3>Caveats</h3>
</a>
<ul>
<li>For ease of use, like <code>pcf</code>, <code>fir</code> <em>does</em> place constraints on the shape of your iModel. There are four.<ol>
<li>Think of the <code>ElementProps</code> type as having an <code>externalSourceAspect</code> property instead of the <code>ExternalSourceAspectProps</code> type having an <code>element</code> property. This allows <code>fir</code> to walk the intermediate iModel tree and find and insert all of the dependencies of the <code>sync</code> argument.</li>
<li>Circular dependencies are impossible to write declaratively. If any of the strings you hang between your object types together form a circle, you can&#39;t represent that iModel with <code>fir</code>. This becomes a problem when (1) is considered. Usually all of the dependencies point up the tree towards the root; a parent must be inserted before its child so the child knows its ID. But now elements point towards their external source aspects. Consider an element <code>A</code> which points to its external source aspect, which points to an external source, which points to a repository. If this repository is contained in a link model, and its modeled element is <code>A</code>, that&#39;s a cycle. It may be necessary to design around this constraint by having separate sources that are not logically separate. You may also omit the external source element if the element is entirely programmatically generated. For example, in the diagram of the cycle below, it may make sense for the link partition to not belong to an external source.</li>
<li>Scope paths must terminate at the root subject. If an element <code>A</code> is scoped to an element <code>B</code> through its external source aspect, then <code>B</code> is a dependency of <code>A</code>, and we must know <code>B</code>&#39;s ID before we can insert <code>A</code>. Because every element in <code>fir</code> has an external source aspect, we need to locate <code>B</code> before we can insert it, which requires knowing its scope. Unless we eventually resolve an element&#39;s scope to the root subject with known ID <code>IModel.rootSubjectId</code>, <code>fir</code> will never terminate as it tries to locate each element in the chain.</li>
<li>Elements must have exactly one external source aspect. This is not a technical limitation. I just haven&#39;t implemented it yet.</li>
</ol>
</li>
</ul>
<p><img src="https://github.com/jackson-at-bentley/fir/blob/main/images/cycle.svg?raw=true" alt="A diagram of the iModel described in the second caveat"></p>

<a href="#getting-started-üå±" id="getting-started-üå±" style="color: inherit; text-decoration: none;">
  <h2>Getting started üå±</h2>
</a>
<pre><code class="language-text">npm install --save fir-for-connectors
</code></pre>
<p>Now install <code>fir</code>&#39;s peer dependency.</p>
<pre><code class="language-text">npm install @itwin/core-common
</code></pre>
<p>You&#39;ll only need <code>@itwin/core-common</code> because <code>fir</code> makes use of those types in its own types.</p>
<pre><code class="language-ts"><span class="hl-7">import</span><span class="hl-1"> </span><span class="hl-7">type</span><span class="hl-1"> { </span><span class="hl-4">Element</span><span class="hl-1">, </span><span class="hl-4">Meta</span><span class="hl-1">, </span><span class="hl-4">Model</span><span class="hl-1">  } </span><span class="hl-7">from</span><span class="hl-1"> </span><span class="hl-6">&#39;fir-for-connectors&#39;</span><span class="hl-1">;</span><br/><span class="hl-7">import</span><span class="hl-1"> { </span><span class="hl-4">Sync</span><span class="hl-1">, </span><span class="hl-4">toElement</span><span class="hl-1">, </span><span class="hl-4">toModel</span><span class="hl-1"> } </span><span class="hl-7">from</span><span class="hl-1"> </span><span class="hl-6">&#39;fir-for-connectors&#39;</span><span class="hl-1">;</span>
</code></pre>
<p>Let&#39;s say we want to add <a href="https://www.itwinjs.org/bis/domains/biscore.ecschema/#urllink">a link</a> to our iModel. We know that the corresponding BIS element is a <code>BisCore:UrlLink</code>. We search the <a href="https://www.itwinjs.org/reference">iTwin API</a> for <em>url link</em> and see <a href="https://www.itwinjs.org/reference/core-common/entities/urllinkprops"><code>UrlLinkProps</code></a>. <code>UrlLinkProps</code> extends <code>ElementProps</code>, so we can use it with <code>fir</code>. Generally, anything with a <em>props</em> at the end is fair game. We&#39;re adding an element, so we define an object of type <code>Element</code> and feed it the props we found.</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">nationalGeographic</span><span class="hl-1">: </span><span class="hl-3">Element</span><span class="hl-1">&lt;</span><span class="hl-3">UrlLinkProps</span><span class="hl-1">&gt; = {</span><br/><span class="hl-1">    </span><span class="hl-4">classFullName:</span><span class="hl-1"> </span><span class="hl-4">UrlLink</span><span class="hl-1">.</span><span class="hl-4">classFullName</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">code:</span><span class="hl-1"> </span><span class="hl-4">Code</span><span class="hl-1">.</span><span class="hl-5">createEmpty</span><span class="hl-1">(),</span><br/><span class="hl-1">    </span><span class="hl-4">model:</span><span class="hl-1"> </span><span class="hl-4">linkModel</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">meta</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">description:</span><span class="hl-1"> </span><span class="hl-6">&#39;the homepage of national geographic&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">url:</span><span class="hl-1"> </span><span class="hl-6">&#39;https://nationalgeographic.com&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">to:</span><span class="hl-1"> </span><span class="hl-4">toElement</span><span class="hl-1">,</span><br/><span class="hl-1">};</span>
</code></pre>
<p>This type should look familiar if you&#39;re used the iTwin API before. It&#39;s nearly identical to <code>UrlLinkProps</code>. There are a couple important differences.</p>
<p>The <code>model</code> property isn&#39;t an ID, an <code>Id64String</code>. It&#39;s another object.</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">linkModel</span><span class="hl-1">: </span><span class="hl-3">Model</span><span class="hl-1">&lt;</span><span class="hl-3">ModelProps</span><span class="hl-1">&gt; = {</span><br/><span class="hl-1">    </span><span class="hl-4">classFullName:</span><span class="hl-1"> </span><span class="hl-4">LinkModel</span><span class="hl-1">.</span><span class="hl-4">classFullName</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">parentModel:</span><span class="hl-1"> </span><span class="hl-6">&#39;repository&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">modeledElement:</span><span class="hl-1"> </span><span class="hl-4">linkPartition</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">to:</span><span class="hl-1"> </span><span class="hl-4">toModel</span><span class="hl-1">,</span><br/><span class="hl-1">};</span>
</code></pre>
<p><code>linkPartition</code> isn&#39;t shown, it&#39;s just an <code>Element&lt;InformationPartitionElementProps&gt;</code>. It&#39;s okay if the props type doesn&#39;t match up with BIS element you want. Just use the closest one, the youngest ancestor props type of the BIS element. You&#39;ll see a <a href="https://www.itwinjs.org/reference/core-backend/elements/linkpartition"><code>LinkPartition</code></a> if you&#39;re searching the iTwin API. It doesn&#39;t end in <em>props</em> so we can&#39;t use that directly. (There are ways to use the iTwin class types with <code>fir</code>, we&#39;ll talk about that later.)</p>
<p>Let&#39;s go back to the URL link.</p>
<p>There&#39;s a strange property called <code>to</code>. This tells <code>fir</code> how to convert its weird node type to <code>ElementProps</code>. It&#39;s boilerplate most of the time, but it also makes <code>fir</code> extendible and allows us to become the synchronizer if you need more power. We&#39;ll come back to this.</p>
<p>Try deleting the <code>to</code> property. If you&#39;re using an editor with a language server, it will show a bunch of red squiggles and your code won&#39;t compile. This is TypeScript in action telling you the <code>to</code> property is required. Same deal with <code>code</code>, a property of <code>UrlLinkProps</code>. Try deleting that too and see what happens.</p>
<p>If you hover over the squiggle, you&#39;ll see a verbose and worrying error message from your friendly compiler.</p>
<pre><code class="language-text">*a few lines of noise*
Property &#39;to&#39; is missing in type &#39;*noise*&#39; but required in type &#39;ElementPatch&#39;. ts(2322)
nodes.ts(53, 5): &#39;to&#39; is declared here.
</code></pre>
<p>That&#39;s okay, <code>fir</code> does some weird type stuff to make it work that probably could be done better if I knew how to write TypeScript. All we need is the very last line. It says the property <code>to</code> is missing!</p>
<p>The other property that&#39;s not in iTwin is <code>meta</code>. This is what <code>fir</code> calls external source aspects, another &quot;thing&quot; in your iModel, similar to an element, where the metadata of your elements is stored, like their versions and checksums. <code>fir</code> uses this information to see when an element has changed.</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">meta</span><span class="hl-1">: </span><span class="hl-3">Meta</span><span class="hl-1"> = {</span><br/><span class="hl-1">    </span><span class="hl-4">classFullName:</span><span class="hl-1"> </span><span class="hl-4">ExternalSourceAspect</span><span class="hl-1">.</span><span class="hl-4">classFullName</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">scope:</span><span class="hl-1"> </span><span class="hl-4">linkPartition</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">anchor:</span><span class="hl-1"> </span><span class="hl-6">&#39;national geographic url&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">kind:</span><span class="hl-1"> </span><span class="hl-6">&#39;json&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">version:</span><span class="hl-1"> </span><span class="hl-6">&#39;1.0.0&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">};</span>
</code></pre>
<p>If you ever want to refer to the root subject, use <code>&#39;root subject&#39;</code>. If you want to refer to the repository model, use <code>&#39;repository model&#39;</code>.</p>
<p>The <code>anchor</code> property is a unique ID for your element, so <code>fir</code> knows how to find it in the iModel. It&#39;s the same thing as <code>identifier</code> in <code>BisCore:ExternalSourceAspect</code>.</p>
<p>URLs don&#39;t usually have parent elements, but if your want to give your element a parent you can do that with the <code>parent</code> property. We give it either an <code>Element</code> or an <code>{ element: Element, relationship: string }</code>. Use the latter form if you want to specify the type of parent-child relationship. If you use the first kind <code>fir</code> will try to guess, but it will probably use <code>BisCore:ElementOwnsChildElements</code>.</p>
<p>Okay, we&#39;re almost done! All that&#39;s left is to tell <code>fir</code> to sync our element. To do that, we need a synchronizer. <code>imodel</code> is your <code>IModelDb</code>.</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">fir</span><span class="hl-1"> = </span><span class="hl-0">new</span><span class="hl-1"> </span><span class="hl-5">Sync</span><span class="hl-1">(</span><span class="hl-4">imodel</span><span class="hl-1">);</span><br/><span class="hl-4">fir</span><span class="hl-1">.</span><span class="hl-5">sync</span><span class="hl-1">(</span><span class="hl-4">nationalGeographic</span><span class="hl-1">);</span>
</code></pre>
<p>That&#39;s it! If you change that version number because you made a patch to your iModel, say to <code>1.0.1</code>, <code>fir</code> will update the element. Otherwise it will skip it.</p>
<p>There&#39;s one more useful method you&#39;ll need to know. If you</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">id</span><span class="hl-1">: </span><span class="hl-3">Id64String</span><span class="hl-1"> = </span><span class="hl-4">fir</span><span class="hl-1">.</span><span class="hl-5">put</span><span class="hl-1">(</span><span class="hl-4">nationalGeographic</span><span class="hl-1">);</span>
</code></pre>
<p>you&#39;ll get the ID of the link in the iModel, the <em>ECInstanceId</em>. You can feed it to other functions in the iTwin API that do useful things, like define relationships. <code>put</code> works like the shell program <code>touch</code>. It puts an element in the iModel if it doesn&#39;t exist and returns its ID. It will <em>never</em> update the element. Use <code>sync</code> for that.</p>

<a href="#tree-trimming" id="tree-trimming" style="color: inherit; text-decoration: none;">
  <h3>Tree trimming</h3>
</a>
<p>Now that we&#39;ve got the synchronization all done, we need to ensure that our source data remains the &#39;single source of truth&#39; for our iModel. This means that each we can define a bijection between the source objects and the iModel objects. For example, if we change the modeled element of a model in the source, we expect the model to be <em>moved</em> in the iModel, and not copied.</p>
<p><code>fir</code> will not do this for you unless you tell it to.</p>
<pre><code class="language-ts"><span class="hl-4">fir</span><span class="hl-1">.</span><span class="hl-5">trim</span><span class="hl-1">(</span><span class="hl-6">&#39;root subject&#39;</span><span class="hl-1">);</span>
</code></pre>
<p>The <code>trim</code> method takes a subtree of the iModel, a branch, and deletes all of the elements and models that weren&#39;t seen during the lifetime of the <code>Sync</code> object and whose children were not seen. The root subject is a good place to call this because most of the iModel descends from it unless you have elements floating in the cytoplasm of the repository model.</p>
<p>Make sure to clean up those too, like repositories and external sources.</p>
<p>It may take multiple passes to remove untouched elements from the iModel depending on how the iModel is traversed. Geometry can prevent definition elements from getting cleaned up during a first pass for <a href="https://www.itwinjs.org/reference/core-backend/imodels/imodeldb/imodeldb.elements/deletedefinitionelements">reasons I don&#39;t entirely understand</a>.</p>

<a href="#can-i-see-an-example-connector" id="can-i-see-an-example-connector" style="color: inherit; text-decoration: none;">
  <h3>Can I see an example connector?</h3>
</a>
<p>Absolutely! Take a look at the integration folder, which has <code>test-connector.ts</code>. It&#39;s the same test connector in <code>connector-framework</code> but it&#39;s written in <code>fir</code>. Currently it&#39;s hard-coded in version <code>1.0.0</code> so <code>fir</code> won&#39;t actually update the elements.</p>

<a href="#more-imodel-things" id="more-imodel-things" style="color: inherit; text-decoration: none;">
  <h3>More iModel things</h3>
</a>
<p><code>fir</code> supports these iModel things.</p>
<ul>
<li>Elements with the <code>Element</code> type.</li>
<li>Models with the <code>Model</code> type.</li>
<li>Aspects with the <code>Aspect</code> type. Use <code>Meta</code> for external source aspects. Note the <code>aspects</code> property on <code>Element</code>. The caveat is that aspects cannot have navigation properties until the iTwin API allows you to get their ID.</li>
<li>Link-table relationships with the <code>Relationship</code> type. These take a little bit of care. They have an <code>anchor</code> property for provenance. You can&#39;t feed them to <code>sync</code> because if any part of a relationship changes it&#39;s considered a different relationship: anchor, class, source, or target. Use <code>put</code> instead. If a property besides these on a relationship changes, like one specified in a custom schema, <code>put</code> will not update the relationship because it must compare unknown properties between two link-table relationships. This is a limitation that should be addressed if the library is ever updated.</li>
<li>Navigation properties by <a href="#extending-fir-">extending or escaping the library</a>. <code>fir</code> comes with the common ones, like parent-child relationships and element-model relationships.</li>
</ul>

<a href="#growing-taller" id="growing-taller" style="color: inherit; text-decoration: none;">
  <h3>Growing taller</h3>
</a>
<p>Syncing an element requires specifying an awful lot of properties that probably seem redundant. Why should I have to define the BIS class of the element I want to insert? Or the code? Doesn&#39;t iTwin know how to make these things for me?</p>
<p>The &#39;props&#39; types that we&#39;ve been using offer a thin wrapper around the underlying database, by design. For a better experience, the iTwin authors made class types that do a lot of this work for you. They usually have a <code>create</code> method or a constructor function. Let&#39;s take a look at an example from the test connector in this repository.</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">category</span><span class="hl-1"> = </span><span class="hl-4">SpatialCategory</span><span class="hl-1">.</span><span class="hl-5">create</span><span class="hl-1">(</span><br/><span class="hl-1">    </span><span class="hl-4">fir</span><span class="hl-1">.</span><span class="hl-4">imodel</span><span class="hl-1">, </span><span class="hl-4">fir</span><span class="hl-1">.</span><span class="hl-5">put</span><span class="hl-1">(</span><span class="hl-4">definitionModel</span><span class="hl-1">), </span><span class="hl-6">&#39;TestConnector&#39;</span><br/><span class="hl-1">);</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">props</span><span class="hl-1">: </span><span class="hl-3">Element</span><span class="hl-1">&lt;</span><span class="hl-3">CategoryProps</span><span class="hl-1">&gt; = {</span><br/><span class="hl-1">    ...</span><span class="hl-4">category</span><span class="hl-1">.</span><span class="hl-5">toJSON</span><span class="hl-1">(),</span><br/><span class="hl-1">    </span><span class="hl-4">model:</span><span class="hl-1"> </span><span class="hl-4">definitionModel</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">parent:</span><span class="hl-1"> </span><span class="hl-0">undefined</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">meta:</span><span class="hl-1"> </span><span class="hl-5">meta</span><span class="hl-1">(</span><span class="hl-6">&#39;Category&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;1.0.0&#39;</span><span class="hl-1">, </span><span class="hl-4">repository</span><span class="hl-1">, </span><span class="hl-4">source</span><span class="hl-1">),</span><br/><span class="hl-1">    </span><span class="hl-4">description:</span><span class="hl-1"> </span><span class="hl-6">&quot;I don&#39;t know what this root category is for yet.&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">rank:</span><span class="hl-1"> </span><span class="hl-4">Rank</span><span class="hl-1">.</span><span class="hl-4">Application</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">to:</span><span class="hl-1"> </span><span class="hl-4">toElement</span><span class="hl-1">,</span><br/><span class="hl-1">};</span>
</code></pre>
<p>When we touch the iTwin APIs we have to make use of <code>put</code>, because the iTwin APIs talk in IDs. Notice we don&#39;t specify the class name or the code. Instead, after we construct the class type, we use <code>toJSON</code> to convert the class type into <code>CategoryProps</code>, then the spread <code>...</code> operator to add it to <code>fir</code>&#39;s element type. If you stop there you have an object of type <code>CategoryProps</code>. We have to overwrite the stuff <code>fir</code> needs to know about, like the model that contains the element. Then we can add properties the class type doesn&#39;t define, like the category description.</p>
<p>The parent property looks weird, because it&#39;s <code>undefined</code>. At runtime, TypeScript can&#39;t know that <code>SpatialCategory</code> doesn&#39;t actually use that parent property. All it knows from the type of <code>toJSON</code> is that it <em>could</em> use it and that its type is <code>Id64String</code>. We have to tell TypeScript that this property actually has the type <code>fir</code> expects, which is an optional <code>Element</code>. We explicitly write <code>undefined</code>, because this optional property is (from my understanding) equivalent to <code>Element | undefined</code>. This is structural typing after all, and a missing property is a different structure.</p>

<a href="#extending-fir-‚ö°" id="extending-fir-‚ö°" style="color: inherit; text-decoration: none;">
  <h2>Extending <code>fir</code> ‚ö°</h2>
</a>
<p>Let&#39;s say we want to add a <a href="https://www.itwinjs.org/bis/domains/biscore.ecschema/#externalsourceattachment"><code>Bis:ExternalSourceAttachment</code></a> to our iModel. I don&#39;t know what this is, but it has a navigation property so we can&#39;t yet use it with <code>fir</code>. Here&#39;s what we need to do.</p>
<pre><code class="language-ts"><span class="hl-0">type</span><span class="hl-1"> </span><span class="hl-3">ExternalSourceAttachment</span><span class="hl-1">&lt;</span><span class="hl-3">P</span><span class="hl-1"> </span><span class="hl-0">extends</span><span class="hl-1"> </span><span class="hl-3">ExternalSourceAttachmentProps</span><span class="hl-1"> = </span><span class="hl-3">ExternalSourceAttachmentProps</span><span class="hl-1">&gt; =</span><br/><span class="hl-1">    </span><span class="hl-3">Omit</span><span class="hl-1">&lt;</span><span class="hl-3">ElementNode</span><span class="hl-1">&lt;</span><span class="hl-3">P</span><span class="hl-1">&gt;, </span><span class="hl-0">keyof</span><span class="hl-1"> </span><span class="hl-3">ExternalSourceAttachmentPatch</span><span class="hl-1">&gt;</span><br/><span class="hl-1">        &amp; </span><span class="hl-3">ExternalSourceAttachmentPatch</span><span class="hl-1">;</span><br/><br/><span class="hl-0">type</span><span class="hl-1"> </span><span class="hl-3">ExternalSourceAttachmentPatch</span><span class="hl-1"> = {</span><br/><span class="hl-1">    </span><span class="hl-4">attaches</span><span class="hl-1">?: </span><span class="hl-3">Source</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">to</span><span class="hl-1">: </span><span class="hl-3">To</span><span class="hl-1">&lt;</span><span class="hl-3">ExternalSourceAttachment</span><span class="hl-1">&lt;</span><span class="hl-3">ExternalSourceAttachmentProps</span><span class="hl-1">&gt;, </span><span class="hl-3">ExternalSourceAttachmentProps</span><span class="hl-1">&gt;</span><br/><span class="hl-1">};</span><br/><br/><span class="hl-0">function</span><span class="hl-1"> </span><span class="hl-5">toExternalSourceAttachment</span><span class="hl-1">(</span><span class="hl-4">sync</span><span class="hl-1">: </span><span class="hl-3">Sync</span><span class="hl-1">, </span><span class="hl-4">attachment</span><span class="hl-1">: </span><span class="hl-3">ExternalSourceAttachment</span><span class="hl-1">): </span><span class="hl-3">ExternalSourceAttachmentProps</span><br/><span class="hl-1">{</span><br/><span class="hl-1">    </span><span class="hl-7">return</span><span class="hl-1"> {</span><br/><span class="hl-1">        ...</span><span class="hl-5">toElement</span><span class="hl-1">(</span><span class="hl-4">sync</span><span class="hl-1">, </span><span class="hl-4">attachment</span><span class="hl-1">),</span><br/><span class="hl-1">        </span><span class="hl-4">attaches:</span><span class="hl-1"> </span><span class="hl-4">attachment</span><span class="hl-1">.</span><span class="hl-4">attaches</span><span class="hl-1"> ? {</span><br/><span class="hl-1">            </span><span class="hl-4">id:</span><span class="hl-1"> </span><span class="hl-4">sync</span><span class="hl-1">.</span><span class="hl-5">put</span><span class="hl-1">(</span><span class="hl-4">attachment</span><span class="hl-1">.</span><span class="hl-4">attaches</span><span class="hl-1">),</span><br/><span class="hl-1">            </span><span class="hl-4">relClassName:</span><span class="hl-1"> </span><span class="hl-4">ExternalSourceAttachmentAttachesSource</span><span class="hl-1">.</span><span class="hl-4">classFullName</span><br/><span class="hl-1">        } : </span><span class="hl-0">undefined</span><br/><span class="hl-1">    };</span><br/><span class="hl-1">}</span>
</code></pre>
<p>The <code>ElementNode</code> type nestled in there is <code>fir</code>&#39;s element type. The only difference between it and <code>Element</code> is that <code>Element</code> can also be <code>&#39;root subject&#39;</code>, and we can&#39;t use <code>Omit</code> on a union type because it doesn&#39;t distribute across the union.</p>
<p>We define our own intermediate type <code>ExternalSourceAttachment</code>. Be careful that you don&#39;t also have a type of the same name from <code>@itwin/core-backend</code>. I like to use qualified imports for the iTwin libraries so I don&#39;t confuse myself. This type looks horrific, but all we&#39;re doing is feeding the &#39;props&#39; type argument <em>P</em> to <code>fir</code>&#39;s element type, which will construct an element type that <code>fir</code> knows how to use. Then we apply our own patch to the result, stripping off the old <code>attaches</code> property and giving it a different type, an external source, called <code>Source</code> in <code>fir</code> for easy access.</p>
<p>Finally, we have to tell <code>fir</code> how to map this new intermediate type to its &#39;props&#39; type in the iTwin library. This is done with a <code>to</code> function as I mentioned earlier.</p>
<p>First, we call <code>toElement</code>, which you&#39;ll remember from all the elements we made above. This turns <code>fir</code>&#39;s element type <code>Element</code> into <code>ElementProps</code>. We dump it into our <code>ExternalSourceAttachmentProps</code> and add the <code>attaches</code> property to complete the type. We make use of <code>put</code> to get the ID of the external source this element refers to.</p>
<p><img src="https://github.com/jackson-at-bentley/fir/blob/main/images/types-tree.svg?raw=true" alt="A diagram of fir&#39;s type tree. Caption reads, &quot;Dashed nodes are convenience types with the type argument defaulted; solid nodes are used when extending the library. The node at the tail of an arrow is a supertype of the node at the head.&quot;"></p>
<p>It turns out we got lucky with this example. When we call <code>toElement</code> we&#39;re trying to assign our <code>ExternalSourceAttachment</code> type to an <code>Element</code> type. This would be a beautiful case of type narrowing if it weren&#39;t for the <code>to</code> properties on the two types. In TypeScript, if you assign a function <code>f</code> to another function <code>g</code> by writing <code>g = f</code>, the function <code>f</code> must have at most as large a domain as <code>g</code>, because functions that have type <code>typeof g</code> give no indication that they do anything with the excess input, like our <code>attaches</code> property. They may even explode. In our case <code>toElement</code> will happily dump everything it receives into the <code>ElementProps</code>.</p>
<p>If the BIS specifications said that the <code>attaches</code> relationship is mandatory, we&#39;d have a problem. <code>Element</code>&#39;s <code>to</code> type doesn&#39;t allow that property. We can use <code>as unknown as Element</code> to tell TypeScript that we&#39;re sure the <code>to</code> function will never be invoked without an <code>attachment</code> property.</p>
<p>The good news is that because of the way props types are implemented, they&#39;re always optional. The same type is used as the parameter to <code>insertElement</code> and <code>updateElement</code>, and properties that are undefined during an update will be cleared. This ensures that our nodes will always be narrowable to <code>Element</code> in an extraordinarily hacky way. However, if your navigation property is mandatory, like <code>bis:SubCategory</code>&#39;s parent, and you forget to specify the property on an insertion, the backend will buck you.</p>
<blockquote>
<p>That&#39;s a lot of work and boilerplate for a new navigation property.</p>
</blockquote>
<p>Yeah, it is. There are two solutions.</p>
<ol>
<li>Rely on the iTwin library to define referencing relationships. I wrote the test connector without having to define a new intermediate element type. Most BIS classes don&#39;t define new navigation properties, and if they do hopefully they have a <code>create</code> that does all of that for you.</li>
<li>Use something like <code>Element&lt;ExternalSourceAttachmentProps&gt;</code> with <code>toElement</code>; remember that only the <code>to</code> types prevent narrowing. Then just use <code>put</code> for the <code>attaches</code> navigation property. Because there&#39;s no intermediate <code>fir</code> type, any additional properties that you give to your element will be handed to the iTwin library.</li>
</ol>
<blockquote>
<p>Dude it&#39;s your library. The whole point of <code>fir</code>&#39;s &#39;tree&#39; of element types is that each one is a supertype of its parent. The <code>to</code> function is bad design because it prevents narrowing when the supertypes aren&#39;t directly assignable to their parent, in which case <em>they&#39;re not supertypes</em> but overlapping types.</p>
</blockquote>
<p>I&#39;m working on it. In the mean time <code>strictFunctionTypes</code> is the compiler option that&#39;s causing this error. There&#39;s no way to say to the compiler, hey, I know this thing isn&#39;t a supertype, but I pinky swear that the other type we&#39;re binding it to isn&#39;t going to invoke its <code>to</code> function without the value we&#39;re hiding from its domain.</p>

<a href="#road-map-and-scattered-thoughts-üöó" id="road-map-and-scattered-thoughts-üöó" style="color: inherit; text-decoration: none;">
  <h2>Road map and scattered thoughts üöó</h2>
</a>
<ul>
<li><input disabled="" type="checkbox"> <em>urgent!</em> Need to figure out how to design the node types to allow the <code>to</code> function to properly narrow; otherwise, syncing is going to be difficult with elements with mandatory properties</li>
<li><input disabled="" type="checkbox"> Test the published package in <code>connector-framework</code></li>
<li><input disabled="" type="checkbox"> Support more than one external source aspect</li>
<li><input disabled="" type="checkbox"> Are there any class types that insert other elements into the iModel? <code>fir</code> won&#39;t know</li>
<li><input disabled="" type="checkbox"> Add node types for physical objects to better support the category navigation property</li>
<li><input checked="" disabled="" type="checkbox"> Sync element aspects</li>
<li><input checked="" disabled="" type="checkbox"> What about syncing <code>RelationshipProps</code>? Link table relationships should never cause cycles</li>
<li><input checked="" disabled="" type="checkbox"> Document the <code>trim</code> method</li>
<li><input checked="" disabled="" type="checkbox"> Trim untethered external sources and repositories. Can we use <code>trim</code>?</li>
<li><input checked="" disabled="" type="checkbox"> Trim a model</li>
</ul>
</div></div>
<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
<div class="tsd-navigation settings">
<details class="tsd-index-accordion"><summary class="tsd-accordion-summary">
<h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4.93896 8.531L12 15.591L19.061 8.531L16.939 6.409L12 11.349L7.06098 6.409L4.93896 8.531Z" fill="var(--color-text)"></path></svg> Settings</h3></summary>
<div class="tsd-accordion-details">
<div class="tsd-filter-visibility">
<h4 class="uppercase">Member Visibility</h4><form>
<ul id="tsd-filter-options">
<li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li>
<li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-private" name="private"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Private</span></label></li>
<li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li>
<li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></form></div>
<div class="tsd-theme-toggle">
<h4 class="uppercase">Theme</h4><select id="theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div>
<nav class="tsd-navigation primary">
<details class="tsd-index-accordion" open><summary class="tsd-accordion-summary">
<h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4.93896 8.531L12 15.591L19.061 8.531L16.939 6.409L12 11.349L7.06098 6.409L4.93896 8.531Z" fill="var(--color-text)"></path></svg> Modules</h3></summary>
<div class="tsd-accordion-details">
<ul>
<li class="current selected"><a href="modules.html">fir-<wbr/>for-<wbr/>connectors</a>
<ul>
<li class="tsd-kind-module"><a href="modules/nodes.html">nodes</a></li>
<li class="tsd-kind-module"><a href="modules/sync.html">sync</a></li></ul></li></ul></div></details></nav></div></div>
<div class="container tsd-generator">
<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></div>
<div class="overlay"></div><script src="assets/main.js"></script></body></html>